<head>
	<script src="../three.js"></script>

	<script src="../js/Detector.js"></script>
	<script src="../js/libs/stats.min.js"></script>
	<script src="../js/util.js"></script>
	<script src="../js/const.js"></script>

	<!-- CDN -->
	<script src="http://codeorigin.jquery.com/jquery-2.0.3.js"></script>

</head>

<body>
<script>
$(function(){
	if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

	var container, stats;
	var camera, scene, renderer;
	var projector, plane, cube;
	var mouse2D, mouse3D, raycaster,

	//キー
	rollOveredFace, isShiftDown = false,
	pressedArrowKey = false;

	//カメラ角度
	phi = 45 * 0.5;
	theta = 60;
	isCtrlDown = false;

	var rollOverMesh, rollOverMaterial;
	var voxelPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3(), normalMatrix = new THREE.Matrix3();
	var cubeGeo, cubeMaterial;
	var i, intersector;

	//デバッグ表示
	var debugHash = new Array();
	var debugInfo;

	init();
	animate();

	function getAxis(){
		var parent = new THREE.Object3D();
		var orig = new THREE.Vector3(0, 0, 0);
		var lineLength = 500;
		var lineX = getLine(orig, new THREE.Vector3(lineLength, 0, 0), 0xff0000);
		var lineY = getLine(orig, new THREE.Vector3(0, lineLength, 0), 0x00ff00);
		var lineZ = getLine(orig, new THREE.Vector3(0, 0, lineLength), 0x0000ff);
		parent.add(lineX);
		parent.add(lineY);
		parent.add(lineZ);
		return parent;
	}

	//デバッグ情報更新
	function updateDebugInfo(){
		var innerHTML = hash2html(debugHash);
		debugInfo.innerHTML = innerHTML;
	}

	function hash2html(hash){
	//function hash2html(){
		var html = '<br><br><br>';
		for(var key in hash){
			var addHTML = key + ' : ' + hash[key] + '<br>';
			html += addHTML;
		}
		return html;
	}

	function init() {

		//ルート
		// container = document.createElement('div');
		container = document.getElementById('container');
		//document.body.appendChild( container );
		//gray background
		$(container).css("background", "#DDDDDD");
		$(container).css("width", "240px");
		$(container).css("height", "1000px");

		//デバッグ表示
		debugInfo = document.createElement('div');
		debugInfo.innerHTML = 'init html';
		debugInfo.style.position = 'absolute';
		container.appendChild(debugInfo);

		//カメラ
		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.y = 800;

		//シーン
		scene = new THREE.Scene();

		scene.add(getAxis());

		//?
		// roll-over helpers
		rollOverGeo = new THREE.CubeGeometry(CUBE_WIDTH, CUBE_WIDTH, CUBE_WIDTH);
		rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
		rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
		scene.add( rollOverMesh );

		// cubes
		cubeGeo = new THREE.CubeGeometry(CUBE_WIDTH, CUBE_WIDTH, CUBE_WIDTH);
		cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c, ambient: 0x00ff80, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture( "square-outline-textured.png" ) } );
		cubeMaterial.ambient = cubeMaterial.color;

		//レイ
		projector = new THREE.Projector();

		//グリッド（もっと簡潔に書ける）
		var size = 500, step = 50;
		var geometry = new THREE.Geometry();
		for ( var i = - size; i <= size; i += step ) {
			geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
			geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );
			geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
			geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );
		}
		var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } );
		var line = new THREE.Line( geometry, material );
		line.type = THREE.LinePieces;
		scene.add( line );

		//?
		plane = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000 ), new THREE.MeshBasicMaterial() );
		plane.rotation.x = - Math.PI / 2;
		plane.visible = false;
		scene.add( plane );

		mouse2D = new THREE.Vector3( 0, 10000, 0.5 );

		//ライト
		var ambientLight = new THREE.AmbientLight( 0x606060 );
		scene.add( ambientLight );
		var directionalLight = new THREE.DirectionalLight( 0xffffff );
		directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
		scene.add( directionalLight );

		//レンダラー
		renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer: true } );
		//描画サイズ
		//ちょっと小さくすることで画面内におさめる
		// renderer.setSize(window.innerWidth-10, window.innerHeight-10);
		renderer.setSize(window.innerWidth-10, window.innerHeight-10);
		container.appendChild( renderer.domElement ); //canvas

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		container.appendChild( stats.domElement );
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener( 'keydown', onDocumentKeyDown, false );
		document.addEventListener( 'keyup', onDocumentKeyUp, false );
		window.addEventListener( 'resize', onWindowResize, false );
	}//init

	//ウィンドウリサイズ時
	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}

	//リアル？
	function getRealIntersector( intersects ) {
		for( i = 0; i < intersects.length; i++ ) {
			intersector = intersects[ i ];
			if ( intersector.object != rollOverMesh ) {
				return intersector;
			}
		}
		return null;
	}

	//ボクセル位置
	function setVoxelPosition( intersector ) {
		if(intersector.face!=null){
			normalMatrix.getNormalMatrix( intersector.object.matrixWorld );
			tmpVec.copy( intersector.face.normal );
			tmpVec.applyMatrix3( normalMatrix ).normalize();
			voxelPosition.addVectors( intersector.point, tmpVec );

			var w = CUBE_WIDTH;
			voxelPosition.x = Math.floor( voxelPosition.x / w ) * w + w/2;
			voxelPosition.y = Math.floor( voxelPosition.y / w ) * w + w/2;
			voxelPosition.z = Math.floor( voxelPosition.z / w ) * w + w/2;
		}
	}

	//マウス移動時
	//X, Y = -1~1
	function onDocumentMouseMove( event ) {
		event.preventDefault();
		mouse2D.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse2D.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	}

	//マウス押下時
	function onDocumentMouseDown( event ) {
		event.preventDefault();
		var intersects = raycaster.intersectObjects( scene.children );
		if ( intersects.length > 0 ) {
			intersector = getRealIntersector( intersects );

			//削除
			if ( isCtrlDown ) {
				if ( intersector.object != plane ) {
					scene.remove( intersector.object );
				}

			//作成
			} else {
				intersector = getRealIntersector( intersects );
				setVoxelPosition( intersector );

				var voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
				voxel.position.copy( voxelPosition );
				voxel.matrixAutoUpdate = false;
				voxel.updateMatrix();
				scene.add( voxel );
			}
		}
	}

	//?
	function onDocumentKeyDown( event ) {
		switch( event.keyCode ) {
			case 16: isShiftDown = true; break;
			case 17: isCtrlDown = true; break;

			//アローキー
			case KEY_LEFT:
			case KEY_RIGHT:
			case KEY_UP:
			case KEY_DOWN:
				pressedArrowKey = event.keyCode;
				break;
		}
	}

	//キーUP時
	function onDocumentKeyUp( event ) {
	switch ( event.keyCode ) {
			case 16: isShiftDown = false; break;
			case 17: isCtrlDown = false; p('ctrl up'); break;

			//アローキー
			case KEY_LEFT:
			case KEY_RIGHT:
			case KEY_UP:
			case KEY_DOWN:
				pressedArrowKey = false;
				break;
		}
	}

	//Update
	function animate() {
		requestAnimationFrame( animate );
		render();
		stats.update();
	}

	//角度を範囲内に
	function degreeInRange(degree){
		if(degree < 0){
			degree += 360;
		}
		else if(degree > 360){
			degree -= 360;
		}
		return degree;
	}

	//thetaを1-179 degreeに
	function thetaInRange(theta){
		if(theta < 1){
			theta = 1;
		}
		else if(theta > 179){
			theta = 179;
		}
		return theta;
	}

	//描画
	function render() {
		if ( isShiftDown ) {
			theta += mouse2D.x * 1.5;
		}
		raycaster = projector.pickingRay( mouse2D.clone(), camera );
		var intersects = raycaster.intersectObjects( scene.children );

		if ( intersects.length > 0 ) {
			intersector = getRealIntersector( intersects );
			if ( intersector ) {
				setVoxelPosition( intersector );
				rollOverMesh.position = voxelPosition;
			}
		}

		//アローキーの回転
		if(pressedArrowKey){
			//シーン回転
			var rotateSpeed = 2;
			switch(pressedArrowKey){
				case KEY_LEFT:
					phi += rotateSpeed;
					break;
				case KEY_RIGHT:
					phi -= rotateSpeed;
					break;
				case KEY_UP:
					theta += rotateSpeed;
					break;
				case KEY_DOWN:
					theta -= rotateSpeed;
					break;
			}
			theta = thetaInRange(theta);
			theta = degreeInRange(theta);
			phi = degreeInRange(phi);
		}
		//デバッグ情報
		debugHash['theta'] = theta;
		debugHash['phi'] = phi;
		updateDebugInfo();


		//ステージではなくカメラを回転させる
		var cameraR = 1500;
		//camera.position.x = cameraR * Math.sin( THREE.Math.degToRad( theta ) );
		//camera.position.z = cameraR * Math.cos( THREE.Math.degToRad( theta ) );

		//球座標
		var sin_theta = Math.sin(THREE.Math.degToRad(theta));
		var cos_theta = Math.cos(THREE.Math.degToRad(theta));
		var sin_phi   = Math.sin(THREE.Math.degToRad(phi));
		var cos_phi   = Math.cos(THREE.Math.degToRad(phi));
		camera.position.x = cameraR * sin_theta * cos_phi;
		camera.position.z = cameraR * sin_theta * sin_phi;
		camera.position.y = cameraR * cos_theta;

		camera.lookAt( scene.position );

		renderer.render( scene, camera );
	}
});
</script>

<div id="container"></div>
</body>
